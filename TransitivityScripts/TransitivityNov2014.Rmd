---
title: "TransitivityAug2015"
author: "Zeynep Enkavi"
date: "August 21, 2014"
output: html_document
---

Organization code
--------------------------------------------------------

### Organize old work space

```{r echo=FALSE, warning=FALSE, message=FALSE}
setwd("~/Dropbox/CDS/Transitivity")

#Load most recent workspace
load("~/Dropbox/CDS/Transitivity/TransitivityCleanWorkspace060614.RData")

#Remove objects that you won't need
rm(a2, a4, a4.lmerTest, Aov.pint, array, b.c, b.etp, b.mtl, b1, btl.c, btl.etp, btl.mtl, btls, col, g, i, l, left.test, m5, m5.lmerTest, opt_left, opt_rigt, reml, row, subject, t2, t2.lmerTest, utility.lmer, intr.c, intr.etp, intr.mtl, j, opt_right, Data.c, Data.etp, Data.mtl, geom.path.df, new.data, u.scales, u.scales.ind)

#Rename choice task files

choice.all <- all
choice.all.data <- all.data
choice.all.data.clean <- all.data.clean
choice.all.data.clean2 <- all.data.clean2
choice.all.data.sr <- all.data.sr
choice.Bars <- Bars
choice.Data <- Data
choice.Intransitive <- Intransitive
choice.Intransitive.clean <- Intransitive.clean
choice.matrices <- matrices
choice.matrix.c <- matrix.c
choice.matrix.etp <- matrix.etp
choice.matrix.mtl <- matrix.mtl
choice.median.cleanintr <- median.cleanintr
choice.medians.c <- medians.c
choice.medians.etp <- medians.etp
choice.medians.mtl <- medians.mtl

#Remove renamed files

rm(all, all.data, all.data.clean, all.data.clean2, all.data.sr, Bars, Data, Intransitive, Intransitive.clean, matrices, matrix.c, matrix.etp, matrix.mtl, median.cleanintr, medians.c, medians.etp, medians.mtl)

source("~/Dropbox/CDS/UsefulFunctions.R")

options(digits=6)

```

### Read numbers task data in:

```{r eval=FALSE, message=FALSE, warning=FALSE}
######### Read Data in
numbers.Data <- read.csv("complete_data_numbers_new.csv", col.names = c("Trialnumber", "Image_left", "Image_right", "RT", "Choice_1right_4left", "SubjectID", "Group"), header=F)
TrialNumber <- read.csv("./grid files/TrialNumbers.csv")
names(numbers.Data)
```

### Organize Data 

First columnis the trial number (starting with 0! ??? to 189)
Second column is the left number
Third column: right number
Fourth column: reaction time (-1 = miss)
Fifth: response (-1: miss; 1 right is bigger, 4: left is bigger) 
Sixth: subject ID
Seventh: patient group 1:MTL, 2: ETL, 3 Control

#### Trial numbers

```{r eval=FALSE}
numbers.Data$Trialnumber <- numbers.Data$Trialnumber+1
```

#### Code choice

In addition to correct choice buttons (1 and 4) there are missed trials (-1) and trials where the wrong button was pressed. Since the wrong button presses were either 3 or 5 they are coded as 4 (left).

```{r eval=FALSE}
table(numbers.Data$Choice_1right_4left)

numbers.Data$Choice <- ifelse(numbers.Data$Choice_1right_4left == 1, "right",
                              ifelse(numbers.Data$Choice_1right_4left == 4, "left",
                                     ifelse(numbers.Data$Choice_1right_4left == 3, "left", ifelse(numbers.Data$Choice_1right_4left == 5, "left", NA))))

table(numbers.Data$Choice, useNA  = "ifany")

numbers.Data$Choice.image <- ifelse(numbers.Data$Choice == "right", numbers.Data$Image_right, ifelse(numbers.Data$Choice == "left", numbers.Data$Image_left, NA))

table(numbers.Data$Choice.image, useNA  = "ifany")
# if all were transitive 1 -> 0, 2 -> 91, 3, -> 182 etc..

numbers.Data$Choice.left1.right0 <- ifelse(numbers.Data$Choice == "left", 1, ifelse(numbers.Data$Choice == "right", 0, NA))

table(numbers.Data$Choice.left1.right0, useNA  = "ifany")
```

#### Assign groups

```{r eval=FALSE}
table(numbers.Data$Group)/190

numbers.Data$Group <- ifelse(numbers.Data$Group == 1, "MTL", 
                ifelse(numbers.Data$Group == 2, "ETL","C"))
```

#### Factorize id's

```{r eval=FALSE}
head(numbers.Data$SubjectID)

numbers.Data$f.id <- as.factor(numbers.Data$SubjectID)

head(numbers.Data$f.id)
```

#### Create unique identifier for each pair (Paste variable)

```{r eval=FALSE}
TrialNumber$Image_right <- ifelse(TrialNumber$Image_right <10, paste(0,as.character(TrialNumber$Image_right,sep="")), TrialNumber$Image_right)
TrialNumber$Image_left <- ifelse(TrialNumber$Image_left <10, paste(0,as.character(TrialNumber$Image_left,sep="")), TrialNumber$Image_left)
TrialNumber$Paste <- paste(TrialNumber$Image_right, TrialNumber$Image_left, sep="")
TrialNumber$Paste<- gsub(" ", "", TrialNumber$Paste)

numbers.Data$Image_right <- ifelse(numbers.Data$Image_right <10, paste(0,as.character(numbers.Data$Image_right,sep="")), numbers.Data$Image_right)
numbers.Data$Image_left <- ifelse(numbers.Data$Image_left <10, paste(0,as.character(numbers.Data$Image_left,sep="")), numbers.Data$Image_left)
numbers.Data$Paste <- paste(numbers.Data$Image_right, numbers.Data$Image_left, sep="")
numbers.Data$Paste<- gsub(" ", "", numbers.Data$Paste)

numbers.Data2 <-  read.csv("complete_data_numbers_new.csv", col.names = c("Trialnumber", "Image_left", "Image_right", "RT", "Choice_1right_4left", "SubjectID", "Group"), header=F)
numbers.Data$Image_right <- numbers.Data2$Image_right
numbers.Data$Image_left <- numbers.Data2$Image_left
rm(numbers.Data2)

numbers.Data$Trial<- rep(NA, nrow(numbers.Data))
for (i in 1:nrow(numbers.Data)){
  numbers.Data$Trial[i]<- TrialNumber$Trial[which(numbers.Data$Paste[i] == TrialNumber$Paste)] 
}

head(TrialNumber)
head(numbers.Data)
```

#### Create Error df with counts of number of trials subjects mispressed or timed out

This will be merged with the Intransitive df with individual intransitivity counts later. 

Note: Mispress doesn't include timeout trials.

```{r eval = FALSE}
#Creates df with subject id in col 1 and number of timed out trials in col 2
numbers.TimeOut <- as.data.frame(table(numbers.Data[which(numbers.Data$RT<0), "SubjectID"]))

#Creates df with subject id in col 1 and number of mispressed trials in col 2
numbers.MisPress <- as.data.frame(table(numbers.Data[which(numbers.Data$Choice_1right_4left != 1 & numbers.Data$Choice_1right_4left != 4 & numbers.Data$Choice_1right_4left != (-1)), "SubjectID"]))

#Creates df with subject id in col 1 and number of both kinds of errors in col 2
numbers.EitherError <- as.data.frame(table(numbers.Data[which(numbers.Data$RT <0 | (numbers.Data$Choice_1right_4left != 1 & numbers.Data$Choice_1right_4left != 4 & numbers.Data$Choice_1right_4left != (-1))), "SubjectID"]))

#Merge above three dfs to get numbers of all errors
numbers.Error <- merge(numbers.MisPress, numbers.TimeOut, by="Var1", all = T)
numbers.Error <- merge(numbers.Error, numbers.EitherError, by="Var1", all = T)
names(numbers.Error) <- c("f.id", "MisPress", "TimeOut", "EitherError")
rm(numbers.TimeOut, numbers.MisPress, numbers.EitherError)
#TO BE MERGED TO INTRANSITIVE DF LATER

```

### Count intransitive choices

#### Create temp df where intransitive choices will be counted by creating the 1140 triplets possible out of 20 options (C(20,3) = 1140)

```{r eval=FALSE}
comb <- t(combn(unique(numbers.Data$Image_left),3))
comb <- as.data.frame(comb)
names(comb) <- c("A", "B", "C")
comb$ApreftoB <- rep(NA, nrow(comb))
comb$BpreftoC <- rep(NA, nrow(comb))
comb$CpreftoA <- rep(NA, nrow(comb))
comb$Intrans <- rep(NA, nrow(comb))
comb$TimeOutApreftoB <- rep(NA, nrow(comb))
comb$TimeOutBpreftoC <- rep(NA, nrow(comb))
comb$TimeOutCpreftoA <- rep(NA, nrow(comb))
comb$TimeOut <- rep(NA, nrow(comb))
comb$TimeOutIntrans <- rep(NA, nrow(comb))
comb$MisPressApreftoB <- rep(NA, nrow(comb))
comb$MisPressBpreftoC <- rep(NA, nrow(comb))
comb$MisPressCpreftoA <- rep(NA, nrow(comb))
comb$MisPress <- rep(NA, nrow(comb))
comb$MisPressIntrans <- rep(NA, nrow(comb))
comb$Error <- rep(NA, nrow(comb))
comb$ErrorIntrans <- rep(NA, nrow(comb))
comb$TrialA <- rep(NA, nrow(comb))
comb$TrialB <- rep(NA, nrow(comb))
comb$TrialC <- rep(NA, nrow(comb))
comb$ThirdTrial <- rep(NA, nrow(comb))
comb$PasteA <- rep(NA, nrow(comb))
comb$PasteB <- rep(NA, nrow(comb))
comb$PasteC <- rep(NA, nrow(comb))
```

#### Group data by subjects 

To later apply the function to count intransitivites to each subject.

```{r eval=FALSE}
data_ind <- group_by(numbers.Data, f.id)
```

#### Function 1: Check intransitivity on one row of comb (in one triplet)

Output: Record choice, intransitivity, TimeOut, MisPress, EitherError, TimeOut+intransitivity, MissPress+intransitivity, EitherError+intransitivity, trial number for each pair, last trial of triplet, pair identifier in one row

```{r eval=FALSE}
comb.row.fn <- function (df, comb.row) {
  # INPUT 
  #   df: individual participants data
  #   comb.row: comb data frame split by row
  j <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$B | df$Image_right == comb.row$B))
  #Record choice for A vs B
  ApreftoB <- ifelse(df$Choice.image[j] == comb.row$A, 1, 0)
  #Record if the trial was TimeOut (i.e. timed out)
  TimeOutApreftoB <- ifelse(df$RT[j] < 0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressApreftoB <- ifelse(df$Choice_1right_4left[j] != 1 & df$Choice_1right_4left[j] != 4 & df$Choice_1right_4left[j] != (-1) , 1, 0)
  #Find trial row in df that has the B vs C choice in comb
  k <- which((df$Image_left == comb.row$B | df$Image_right == comb.row$B) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for B vs C
  BpreftoC <- ifelse(df$Choice.image[k] == comb.row$B, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutBpreftoC <- ifelse(df$RT[k] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressBpreftoC <- ifelse(df$Choice_1right_4left[k] != 1 & df$Choice_1right_4left[k] != 4 & df$Choice_1right_4left[k] != (-1), 1, 0)
  #Find trial row in df that has the A vs C choice in comb
  l <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for A vs C
  CpreftoA <- ifelse(df$Choice.image[l] == comb.row$C, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutCpreftoA <- ifelse(df$RT[l] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressCpreftoA <- ifelse(df$Choice_1right_4left[l] != 1 & df$Choice_1right_4left[l] != 4 & df$Choice_1right_4left[l] != (-1) , 1, 0)
  #A triplet is intransitive if either A>B, B>C and C>A OR A<B, B<C and C<A (the second is the reverse) #Changed on 9/18/14 to assign NA whenever there is NA in choice (which would be the case if timeout is coded so)
  Intrans <- ifelse (ApreftoB == 1 & BpreftoC == 1 & CpreftoA == 1, 1, 
                     ifelse(ApreftoB == 0 & BpreftoC == 0 & CpreftoA == 0, 1, 
                            ifelse(is.na(ApreftoB) == T | is.na(BpreftoC) == T | is.na(CpreftoA) == T, NA,0)))
  #A triplet involves a TimeOut if any of the three trials involved has timed out
  TimeOut <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1, 1, 0)
  #A triplet involves a MisPress if any of the three trials were mispressed
  MisPress <- ifelse(MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
    #A triplet involves an Error if any of the three trials were timed out or mispressed
  Error <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1| MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
  #Mark triplets where there is both an TimeOut and an intransitivity
  #TimeOutIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an MisPress and an intransitivity
  MisPressIntrans <- ifelse((MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an TimeOut or Mispress and an intransitivity
  ErrorIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1 | MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
  TrialA <- df$Trialnumber[j]
  TrialB <- df$Trialnumber[k]
  TrialC <- df$Trialnumber[l]
  ThirdTrial <- max(TrialA, TrialB, TrialC)
  PasteA <- numbers.Data$Paste[j]
  PasteB <- numbers.Data$Paste[k]
  PasteC <- numbers.Data$Paste[l]
  # setup data to return
  ret.dat <- data.frame(A = comb.row$A, 
                        B = comb.row$B,
                        C = comb.row$C,
                        ApreftoB = ApreftoB,
                        BpreftoC = BpreftoC,
                        CpreftoA = CpreftoA,
                        Intrans = Intrans,
                        TimeOutApreftoB = TimeOutApreftoB,
                        TimeOutBpreftoC = TimeOutBpreftoC,
                        TimeOutCpreftoA = TimeOutCpreftoA,
                        TimeOut = TimeOut,
                        #TimeOutIntrans = TimeOutIntrans,
                        MisPressApreftoB = MisPressApreftoB,
                        MisPressBpreftoC = MisPressBpreftoC,
                        MisPressCpreftoA = MisPressCpreftoA,
                        MisPress = MisPress,
                        MisPressIntrans = MisPressIntrans,
                        Error = Error,
                        ErrorIntrans = ErrorIntrans,
                        TrialA = TrialA,
                        TrialB = TrialB,
                        TrialC = TrialC,
                        ThirdTrial = ThirdTrial,
                        PasteA = PasteA,
                        PasteB = PasteB,
                        PasteC = PasteC)
  return(ret.dat)
}
```

Note: Considered coding Mispresses like timeouts where they don't factor in to the intransitivity calculation at all but unlike timeouts where we have no guess on preference we do make a guess for the mispress trials so it made more sense to me to keep track of them instead.

#### Create continuous triplet variable 

To act as levels when applying the row level function to the subject level df

```{r eval=FALSE}
comb <- mutate(comb, 
               id = 1:nrow(comb))
```

#### Function 2: Apply function 1 (row level intransitivity calculation) to subset of data including all triplets for one participant

```{r eval=FALSE}
comb.fn <- function(Data.cut, comb) {
  ddply(comb, .(id), comb.row.fn, df = Data.cut)
}
```

#### Count intransitivities for all subjects [takes time ~ 6 min]

Combine intransitivity calculation for all participant by applying to subject level calculation to all participants  
Output: 1140*number of subject rows recording with output of comb.row.fn function

```{r eval=FALSE}
numbers.all <- ddply(numbers.Data, .(f.id, Group), comb.fn, comb = comb, .progress="text")
```

#### Subject level: Summarize triplet level intransitivity on subject level 

Output: nrow = number of subjects  
Note TimeOut, MisPress and Error are large choice2 (not matching the Error df) because they are the number of triplets (not trials!) that involve one OR MORE of these errors (so not triple counting)

...IntransTriplets are all 0 because error choices (and therefore also Intrans) are coded as NA.


```{r eval=FALSE}
numbers.Intransitive <- ddply(numbers.all, .(f.id, Group), summarise, 
             Intrans = sum(Intrans, na.rm=T),
             TimeOutTriplets = sum(TimeOut, na.rm=T),
             MisPressTriplets = sum(MisPress),
             ErrorTriplets = sum(Error, na.rm=T),
             #TimeOutIntransTriplets = sum(TimeOutIntrans),
             MisPressIntransTriplets = sum(MisPressIntrans, na.rm=T),
             ErrorIntransTriplets = sum(ErrorIntrans, na.rm=T))

#not working: MisPressTriplets, ErrorTriplets, TimeOutIntransTriplets (should be 0), MisPressIntransTriplets, ErrorIntransTriplets
```

#### Subject level: Assign number of missed trials from the Error df to the correct subject in Intrans df

```{r eval=FALSE}
# Create additional subject level variables and calculations of percentages
numbers.Intransitive$TimeOutTrials <- rep(NA, nrow(numbers.Intransitive))
numbers.Intransitive$MisPressTrials <- rep(NA, nrow(numbers.Intransitive))
numbers.Intransitive$EitherErrorTrials <- rep(NA, nrow(numbers.Intransitive))

#Assign number of missed trials from the Error df to the correct subject in Intrans df
for (i in 1:nrow(numbers.Error)){
  j <- which(as.character(numbers.Intransitive$f.id) == as.character(numbers.Error$f.id[i]))
  numbers.Intransitive$TimeOutTrials[j] <- numbers.Error$TimeOut[i]
  numbers.Intransitive$MisPressTrials[j] <- numbers.Error$MisPress[i]
  numbers.Intransitive$EitherErrorTrials[j] <- numbers.Error$EitherError[i]
}

#Or give 0 if there are no missed trials
numbers.Intransitive$TimeOutTrials <- ifelse(is.na(numbers.Intransitive$TimeOutTrials) == T, 0, numbers.Intransitive$TimeOutTrials)
numbers.Intransitive$MisPressTrials <- ifelse(is.na(numbers.Intransitive$MisPressTrials) == T, 0, numbers.Intransitive$MisPressTrials)
numbers.Intransitive$EitherErrorTrials <- ifelse(is.na(numbers.Intransitive$EitherErrorTrials) == T, 0, numbers.Intransitive$EitherErrorTrials)
```

#### Subject level: Calculate percentages of intransitivities and timed out/mispressed trials


```{r eval=FALSE}
#Trial level calculations
numbers.Intransitive$PercentTimeOutTrials <- numbers.Intransitive$TimeOutTrials/190*100
numbers.Intransitive$PercentMisPressTrials <- numbers.Intransitive$MisPressTrials/190*100
numbers.Intransitive$PercentEitherErrorTrials <- numbers.Intransitive$EitherErrorTrials/190*100

#Triplet level calculations
#numbers.Intransitive$PercentIntr <- numbers.Intransitive$Intrans/1140*100
numbers.Intransitive$PercentTimeOutTriplets <- numbers.Intransitive$TimeOutTriplets/1140*100
numbers.Intransitive$PercentMisPressTriplets <- numbers.Intransitive$MisPressTriplets/1140*100
numbers.Intransitive$PercentEitherErrorTriplets <- numbers.Intransitive$ErrorTriplets/1140*100

#Percent of intransitivies that include an error (now only mispress errors because timeouts are not counted in Intrans)
numbers.Intransitive$PIntrError<- numbers.Intransitive$ErrorIntrans/ numbers.Intransitive$Intrans *100

numbers.Intransitive$CleanTriplets <- 1140 - numbers.Intransitive$ErrorTriplets
numbers.Intransitive$CleanIntr <- numbers.Intransitive$Intrans - numbers.Intransitive$ErrorIntransTriplets
numbers.Intransitive$CleanPercentIntr <- numbers.Intransitive$CleanIntr/numbers.Intransitive$CleanTriplets *100
```

REPEAT SAME CLEANING OF TIMEOUTS FOR CHOICE DATA
-----------------------------------------------------------------

### Read choice2 task data in:

```{r eval=FALSE, message=FALSE, warning=FALSE}
######### Read Data in
choice2.Data <- read.csv("./grid files/complete_data.csv")

names(choice2.Data)
```

### Organize Data 

#### Code choice

In addition to correct choice buttons (1 and 4) there are missed trials (-1) and trials where the wrong button was pressed. Since the wrong button presses were either 3 or 5 they are coded as 4 (left).

```{r eval=FALSE}
table(choice2.Data$Choice_1left_4right)

#Make sure TimeOut trials are coded correctly for choice (this only seems to be a problem for one single trial (4) for one subject (3574))

choice2.Data$Choice_1left_4right <- ifelse(choice2.Data$RT<0, (-1), choice2.Data$Choice_1left_4right) 

table(choice2.Data$Choice_1left_4right)


choice2.Data$Choice <- ifelse(choice2.Data$Choice_1left_4right == 1, "left",
                              ifelse(choice2.Data$Choice_1left_4right == 4, "right",
                                     ifelse(choice2.Data$Choice_1left_4right == 2, "left", ifelse(choice2.Data$Choice_1left_4right == 3, "right", ifelse(choice2.Data$Choice_1left_4right == 5, "right", NA)))))

table(choice2.Data$Choice, useNA  = "ifany")

choice2.Data$Choice.image <- ifelse(choice2.Data$Choice == "right", choice2.Data$Image_right, ifelse(choice2.Data$Choice == "left", choice2.Data$Image_left, NA))

table(choice2.Data$Choice.image, useNA  = "ifany")
# if all were transitive 1 -> 0, 2 -> 91, 3, -> 182 etc..

choice2.Data$Choice.left1.right0 <- ifelse(choice2.Data$Choice == "left", 1, ifelse(choice2.Data$Choice == "right", 0, NA))

table(choice2.Data$Choice.left1.right0, useNA  = "ifany")
```

#### Assign groups

```{r eval=FALSE}
table(choice2.Data$Group)/190

choice2.Data$Group <- ifelse(choice2.Data$Group == 1, "MTL", 
                ifelse(choice2.Data$Group == 2, "ETL","C"))
```

#### Factorize id's

```{r eval=FALSE}
head(choice2.Data$SubjectID)

choice2.Data$f.id <- as.factor(choice2.Data$SubjectID)

head(choice2.Data$f.id)
```

#### Create unique identifier for each pair (Paste variable)

```{r eval=FALSE}
choice2.Data$Image_right <- ifelse(choice2.Data$Image_right <10, paste(0,as.character(choice2.Data$Image_right,sep="")), choice2.Data$Image_right)
choice2.Data$Image_left <- ifelse(choice2.Data$Image_left <10, paste(0,as.character(choice2.Data$Image_left,sep="")), choice2.Data$Image_left)
choice2.Data$Paste <- paste(choice2.Data$Image_right, choice2.Data$Image_left, sep="")
choice2.Data$Paste<- gsub(" ", "", choice2.Data$Paste)

choice2.Data2 <-  read.csv("./grid files/complete_data.csv")
choice2.Data$Image_right <- choice2.Data2$Image_right
choice2.Data$Image_left <- choice2.Data2$Image_left
rm(choice2.Data2)

choice2.Data$Trial<- rep(NA, nrow(choice2.Data))
for (i in 1:nrow(choice2.Data)){
  choice2.Data$Trial[i]<- TrialNumber$Trial[which(choice2.Data$Paste[i] == TrialNumber$Paste)] 
}

head(TrialNumber)
head(choice2.Data)
```

#### Create Error df with counts of number of trials subjects mispressed or timed out

This will be merged with the Intransitive df with individual intransitivity counts later. 

Note: Mispress doesn't include timeout trials.

```{r eval = FALSE}
#Creates df with subject id in col 1 and number of timed out trials in col 2
choice2.TimeOut <- as.data.frame(table(choice2.Data[which(choice2.Data$RT<0), "SubjectID"]))

#Creates df with subject id in col 1 and number of mispressed trials in col 2
choice2.MisPress <- as.data.frame(table(choice2.Data[which(choice2.Data$Choice_1left_4right != 1 & choice2.Data$Choice_1left_4right != 4 & choice2.Data$Choice_1left_4right != (-1)), "SubjectID"]))

#Creates df with subject id in col 1 and number of both kinds of errors in col 2
choice2.EitherError <- as.data.frame(table(choice2.Data[which(choice2.Data$RT <0 | (choice2.Data$Choice_1left_4right != 1 & choice2.Data$Choice_1left_4right != 4 & choice2.Data$Choice_1left_4right != (-1))), "SubjectID"]))

#Merge above three dfs to get choice2 of all errors
choice2.Error <- merge(choice2.MisPress, choice2.TimeOut, by="Var1", all = T)
choice2.Error <- merge(choice2.Error, choice2.EitherError, by="Var1", all = T)
names(choice2.Error) <- c("f.id", "MisPress", "TimeOut", "EitherError")
rm(choice2.TimeOut, choice2.MisPress, choice2.EitherError)
#TO BE MERGED TO INTRANSITIVE DF LATER

```

### Count intransitive choices

#### Create temp df where intransitive choices will be counted by creating the 1140 triplets possible out of 20 options (C(20,3) = 1140)

```{r eval=FALSE}
comb <- t(combn(unique(choice2.Data$Image_left),3))
comb <- as.data.frame(comb)
names(comb) <- c("A", "B", "C")
comb$ApreftoB <- rep(NA, nrow(comb))
comb$BpreftoC <- rep(NA, nrow(comb))
comb$CpreftoA <- rep(NA, nrow(comb))
comb$Intrans <- rep(NA, nrow(comb))
comb$TimeOutApreftoB <- rep(NA, nrow(comb))
comb$TimeOutBpreftoC <- rep(NA, nrow(comb))
comb$TimeOutCpreftoA <- rep(NA, nrow(comb))
comb$TimeOut <- rep(NA, nrow(comb))
comb$TimeOutIntrans <- rep(NA, nrow(comb))
comb$MisPressApreftoB <- rep(NA, nrow(comb))
comb$MisPressBpreftoC <- rep(NA, nrow(comb))
comb$MisPressCpreftoA <- rep(NA, nrow(comb))
comb$MisPress <- rep(NA, nrow(comb))
comb$MisPressIntrans <- rep(NA, nrow(comb))
comb$Error <- rep(NA, nrow(comb))
comb$ErrorIntrans <- rep(NA, nrow(comb))
comb$TrialA <- rep(NA, nrow(comb))
comb$TrialB <- rep(NA, nrow(comb))
comb$TrialC <- rep(NA, nrow(comb))
comb$ThirdTrial <- rep(NA, nrow(comb))
comb$PasteA <- rep(NA, nrow(comb))
comb$PasteB <- rep(NA, nrow(comb))
comb$PasteC <- rep(NA, nrow(comb))
```

#### Group data by subjects 

To later apply the function to count intransitivites to each subject.

```{r eval=FALSE}
data_ind <- group_by(choice2.Data, f.id)
```

#### Function 1: Check intransitivity on one row of comb (in one triplet)

Output: Record choice, intransitivity, TimeOut, MisPress, EitherError, TimeOut+intransitivity, MissPress+intransitivity, EitherError+intransitivity, trial number for each pair, last trial of triplet, pair identifier in one row

```{r eval=FALSE}
comb.row.fn <- function (df, comb.row) {
  # INPUT 
  #   df: individual participants data
  #   comb.row: comb data frame split by row
  j <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$B | df$Image_right == comb.row$B))
  #Record choice for A vs B
  ApreftoB <- ifelse(df$Choice.image[j] == comb.row$A, 1, 0)
  #Record if the trial was TimeOut (i.e. timed out)
  TimeOutApreftoB <- ifelse(df$RT[j] < 0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressApreftoB <- ifelse(df$Choice_1left_4right[j] != 1 & df$Choice_1left_4right[j] != 4 & df$Choice_1left_4right[j] != (-1) , 1, 0)
  #Find trial row in df that has the B vs C choice in comb
  k <- which((df$Image_left == comb.row$B | df$Image_right == comb.row$B) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for B vs C
  BpreftoC <- ifelse(df$Choice.image[k] == comb.row$B, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutBpreftoC <- ifelse(df$RT[k] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressBpreftoC <- ifelse(df$Choice_1left_4right[k] != 1 & df$Choice_1left_4right[k] != 4 & df$Choice_1left_4right[k] != (-1), 1, 0)
  #Find trial row in df that has the A vs C choice in comb
  l <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for A vs C
  CpreftoA <- ifelse(df$Choice.image[l] == comb.row$C, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutCpreftoA <- ifelse(df$RT[l] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressCpreftoA <- ifelse(df$Choice_1left_4right[l] != 1 & df$Choice_1left_4right[l] != 4 & df$Choice_1left_4right[l] != (-1) , 1, 0)
  #A triplet is intransitive if either A>B, B>C and C>A OR A<B, B<C and C<A (the second is the reverse) #Changed on 9/18/14 to assign NA whenever there is NA in choice (which would be the case if timeout is coded so)
  Intrans <- ifelse (ApreftoB == 1 & BpreftoC == 1 & CpreftoA == 1, 1, 
                     ifelse(ApreftoB == 0 & BpreftoC == 0 & CpreftoA == 0, 1, 
                            ifelse(is.na(ApreftoB) == T | is.na(BpreftoC) == T | is.na(CpreftoA) == T, NA,0)))
  #A triplet involves a TimeOut if any of the three trials involved has timed out
  TimeOut <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1, 1, 0)
  #A triplet involves a MisPress if any of the three trials were mispressed
  MisPress <- ifelse(MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
    #A triplet involves an Error if any of the three trials were timed out or mispressed
  Error <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1| MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
  #Mark triplets where there is both an TimeOut and an intransitivity
  #TimeOutIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an MisPress and an intransitivity
  MisPressIntrans <- ifelse((MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an TimeOut or Mispress and an intransitivity
  ErrorIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1 | MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
  TrialA <- df$Trialnumber[j]
  TrialB <- df$Trialnumber[k]
  TrialC <- df$Trialnumber[l]
  ThirdTrial <- max(TrialA, TrialB, TrialC)
  PasteA <- choice2.Data$Paste[j]
  PasteB <- choice2.Data$Paste[k]
  PasteC <- choice2.Data$Paste[l]
  # setup data to return
  ret.dat <- data.frame(A = comb.row$A, 
                        B = comb.row$B,
                        C = comb.row$C,
                        ApreftoB = ApreftoB,
                        BpreftoC = BpreftoC,
                        CpreftoA = CpreftoA,
                        Intrans = Intrans,
                        TimeOutApreftoB = TimeOutApreftoB,
                        TimeOutBpreftoC = TimeOutBpreftoC,
                        TimeOutCpreftoA = TimeOutCpreftoA,
                        TimeOut = TimeOut,
                        #TimeOutIntrans = TimeOutIntrans,
                        MisPressApreftoB = MisPressApreftoB,
                        MisPressBpreftoC = MisPressBpreftoC,
                        MisPressCpreftoA = MisPressCpreftoA,
                        MisPress = MisPress,
                        MisPressIntrans = MisPressIntrans,
                        Error = Error,
                        ErrorIntrans = ErrorIntrans,
                        TrialA = TrialA,
                        TrialB = TrialB,
                        TrialC = TrialC,
                        ThirdTrial = ThirdTrial,
                        PasteA = PasteA,
                        PasteB = PasteB,
                        PasteC = PasteC)
  return(ret.dat)
}
```

#### Create continuous triplet variable 

To act as levels when applying the row level function to the subject level df

```{r eval=FALSE}
comb <- mutate(comb, 
               id = 1:nrow(comb))
```

#### Function 2: Apply function 1 (row level intransitivity calculation) to subset of data including all triplets for one participant

```{r eval=FALSE}
comb.fn <- function(Data.cut, comb) {
  ddply(comb, .(id), comb.row.fn, df = Data.cut)
}
```

#### Count intransitivities for all subjects [takes time ~ 6 min]

Combine intransitivity calculation for all participant by applying to subject level calculation to all participants  
Output: 1140*number of subject rows recording with output of comb.row.fn function

```{r eval=FALSE}
choice2.all <- ddply(choice2.Data, .(f.id, Group), comb.fn, comb = comb, .progress="text")
```

#### Subject level: Summarize triplet level intransitivity on subject level 

Output: nrow = number of subjects  
Note TimeOut, MisPress and Error are large choice2 (not matching the Error df) because they are the number of triplets (not trials!) that involve one OR MORE of these errors (so not triple counting)

...IntransTriplets are all 0 because error choices (and therefore also Intrans) are coded as NA.


```{r eval=FALSE}
choice2.Intransitive <- ddply(choice2.all, .(f.id, Group), summarise, 
             Intrans = sum(Intrans, na.rm=T),
             TimeOutTriplets = sum(TimeOut, na.rm=T),
             MisPressTriplets = sum(MisPress),
             ErrorTriplets = sum(Error, na.rm=T),
             #TimeOutIntransTriplets = sum(TimeOutIntrans),
             MisPressIntransTriplets = sum(MisPressIntrans, na.rm=T),
             ErrorIntransTriplets = sum(ErrorIntrans, na.rm=T))

#not working: MisPressTriplets, ErrorTriplets, TimeOutIntransTriplets (should be 0), MisPressIntransTriplets, ErrorIntransTriplets
```

#### Subject level: Assign number of missed trials from the Error df to the correct subject in Intrans df

```{r eval=FALSE}
# Create additional subject level variables and calculations of percentages
choice2.Intransitive$TimeOutTrials <- rep(NA, nrow(choice2.Intransitive))
choice2.Intransitive$MisPressTrials <- rep(NA, nrow(choice2.Intransitive))
choice2.Intransitive$EitherErrorTrials <- rep(NA, nrow(choice2.Intransitive))

#Assign number of missed trials from the Error df to the correct subject in Intrans df
for (i in 1:nrow(choice2.Error)){
  j <- which(as.character(choice2.Intransitive$f.id) == as.character(choice2.Error$f.id[i]))
  choice2.Intransitive$TimeOutTrials[j] <- choice2.Error$TimeOut[i]
  choice2.Intransitive$MisPressTrials[j] <- choice2.Error$MisPress[i]
  choice2.Intransitive$EitherErrorTrials[j] <- choice2.Error$EitherError[i]
}

#Or give 0 if there are no missed trials
choice2.Intransitive$TimeOutTrials <- ifelse(is.na(choice2.Intransitive$TimeOutTrials) == T, 0, choice2.Intransitive$TimeOutTrials)
choice2.Intransitive$MisPressTrials <- ifelse(is.na(choice2.Intransitive$MisPressTrials) == T, 0, choice2.Intransitive$MisPressTrials)
choice2.Intransitive$EitherErrorTrials <- ifelse(is.na(choice2.Intransitive$EitherErrorTrials) == T, 0, choice2.Intransitive$EitherErrorTrials)
```

#### Subject level: Calculate percentages of intransitivities and timed out/mispressed trials


```{r eval=FALSE}
#Trial level calculations
choice2.Intransitive$PercentTimeOutTrials <- choice2.Intransitive$TimeOutTrials/190*100
choice2.Intransitive$PercentMisPressTrials <- choice2.Intransitive$MisPressTrials/190*100
choice2.Intransitive$PercentEitherErrorTrials <- choice2.Intransitive$EitherErrorTrials/190*100

#Triplet level calculations
#choice2.Intransitive$PercentIntr <- choice2.Intransitive$Intrans/1140*100
choice2.Intransitive$PercentTimeOutTriplets <- choice2.Intransitive$TimeOutTriplets/1140*100
choice2.Intransitive$PercentMisPressTriplets <- choice2.Intransitive$MisPressTriplets/1140*100
choice2.Intransitive$PercentEitherErrorTriplets <- choice2.Intransitive$ErrorTriplets/1140*100

#Percent of intransitivies that include an error (now only mispress errors because timeouts are not counted in Intrans)
choice2.Intransitive$PIntrError<- choice2.Intransitive$ErrorIntrans/ choice2.Intransitive$Intrans *100

choice2.Intransitive$CleanTriplets <- 1140 - choice2.Intransitive$ErrorTriplets
choice2.Intransitive$CleanIntr <- choice2.Intransitive$Intrans - choice2.Intransitive$ErrorIntransTriplets
choice2.Intransitive$CleanPercentIntr <- choice2.Intransitive$CleanIntr/choice2.Intransitive$CleanTriplets *100
```

```{r echo=FALSE, eval=FALSE}
#Choice and choice2 quick comparison. Does the slight cleaning difference make a difference? No (good).

choice.Intransitive$Group == choice2.Intransitive$Group
table(choice2.Intransitive$Group)
table(choice2.Intransitive$Group)
table(choice.Intransitive$Group)
choice2.Intransitive$Group[choice.Intransitive$Group == choice2.Intransitive$Group]
choice2.Intransitive$Group[choice.Intransitive$Group != choice2.Intransitive$Group]
choice.Intransitive$Intrans == choice2.Intransitive$Intrans
cbind(choice2.Intransitive$Intrans[choice.Intransitive$Intrans != choice2.Intransitive$Intrans],choice.Intransitive$Intrans[choice.Intransitive$Intrans != choice2.Intransitive$Intrans])

choice.Intransitive$CleanIntr == choice2.Intransitive$Intrans

cbind(choice2.Intransitive$Intrans[choice.Intransitive$Intrans != choice2.Intransitive$Intrans],choice.Intransitive$CleanIntr[choice.Intransitive$Intrans != choice2.Intransitive$Intrans])

cbind(choice2.Intransitive$Intrans[choice.Intransitive$CleanIntr != choice2.Intransitive$Intrans],choice.Intransitive$CleanIntr[choice.Intransitive$CleanIntr != choice2.Intransitive$Intrans])

which(choice.Intransitive$CleanIntr == choice2.Intransitive$Intrans)
which(choice.Intransitive$CleanIntr != choice2.Intransitive$Intrans)
View(choice.Intransitive)

choice.Intransitive$CleanIntr == choice2.Intransitive$CleanIntr
choice.Intransitive$CleanPercentIntr == choice2.Intransitive$CleanPercentIntr


```

#### Trial level: Create pair level intransitivity count

**Temp df before aggregating. Has numbers.all three "Paste"s (ie trials in one column)**

```{r eval=FALSE}
numbers.all.m <- melt(numbers.all[, c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans","TrialA", "TrialB", "TrialC")], id = c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans"))
```

**Aggregate df to sum (I think Err and ErrIntrans are less usefull here. Using only Intrans so far.) Note: Total intransitivities will be triple counted this way (because numbers.all three pairs that are involved in an intransitivity take the dummy variable 1)**

```{r eval=FALSE}
numbers.all.ag <- aggregate(numbers.all.m[,c("Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans")], by = list(f.id = numbers.all.m$f.id, Group = numbers.all.m$Group, Trialnumber = numbers.all.m$value), FUN = "sum")
```

**Merge Intransitivity info with rest of trial level data**

```{r eval=FALSE}
numbers.all.data <- merge(numbers.Data, numbers.all.ag, by = c("f.id", "Group", "Trialnumber"))

rm(numbers.all.ag, numbers.all.m)
```

#### Trial level: Create centered trial number and quadratic trial term

```{r eval=FALSE}
numbers.all.data$c.Trialnumber <- numbers.all.data$Trialnumber - mean(numbers.all.data$Trialnumber)
numbers.all.data$c.TrialQuad <- numbers.all.data$c.Trialnumber^2
```

#### Trial level: Create df counting how many times each trial was the last trial (C>A) leading to intransitivity

```{r eval=FALSE}

Trialnumber.df <- as.data.frame(table(numbers.all$ThirdTrial, numbers.all$Intrans, numbers.all$f.id))

#head(Trialnumber.df, 190)

names(Trialnumber.df) <- c("Trialnumber", "Intrans", "f.id", "TimesThirdInIntrans")
```

**Exclude those where there is no intransitivity**

```{r eval=FALSE}
Trialnumber.df <- Trialnumber.df[Trialnumber.df$Intrans == 1,]
```

**Organize classes of columns**

```{r eval=FALSE}

Trialnumber.df$Trialnumber <- as.numeric(as.character(Trialnumber.df$Trialnumber))
Trialnumber.df$Intrans <- as.numeric(as.character(Trialnumber.df$Intrans))
```

**Merge w pair level data**

```{r eval=FALSE}

numbers.all.data <- merge(numbers.all.data, Trialnumber.df[,c("Trialnumber", "f.id", "TimesThirdInIntrans")], by = c("Trialnumber", "f.id"), numbers.all.x=T)

numbers.all.data <- numbers.all.data[order(numbers.all.data$f.id, numbers.all.data$Trialnumber),]
```

**Replace NA's in IntransFreq w 0's (these trials have never been the largest trial in a triplet)**

```{r eval=FALSE}
numbers.all.data$IntransFreq <- ifelse(is.na(numbers.all.data$TimesThirdInIntrans), 0, numbers.all.data$TimesThirdInIntrans)
```

#### Trial level: variables that are triple counted in trial level df numbers.all.data - rename them to avoid confusion later

**Note also these are not triple counted in Intransitive df because that is summarized directly from triplet level**

```{r eval=FALSE}
names(numbers.all.data)[which(names(numbers.all.data) == "Intrans")] <- "IntransTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "MisPress")] <- "MisPressTripletsTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "Error")] <- "ErrorTripletsTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "MisPressIntrans")] <- "MisPressIntransTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "ErrorIntrans")] <- "ErrorIntransTripleCounted"
```

#### Trial level: Create pair level intransitivity count

**Temp df before aggregating. Has choice2.all three "Paste"s (ie trials in one column)**

```{r eval=FALSE}
choice2.all.m <- melt(choice2.all[, c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans","TrialA", "TrialB", "TrialC")], id = c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans"))
```

**Aggregate df to sum (I think Err and ErrIntrans are less usefull here. Using only Intrans so far.) Note: Total intransitivities will be triple counted this way (because choice2.all three pairs that are involved in an intransitivity take the dummy variable 1)**

```{r eval=FALSE}
choice2.all.ag <- aggregate(choice2.all.m[,c("Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans")], by = list(f.id = choice2.all.m$f.id, Group = choice2.all.m$Group, Trialnumber = choice2.all.m$value), FUN = "sum")
```

**Merge Intransitivity info with rest of trial level data**

```{r eval=FALSE}
choice2.all.data <- merge(choice2.Data, choice2.all.ag, by = c("f.id", "Group", "Trialnumber"))

rm(choice2.all.ag, choice2.all.m)
```

#### Trial level: Create centered trial number and quadratic trial term

```{r eval=FALSE}
choice2.all.data$c.Trialnumber <- choice2.all.data$Trialnumber - mean(choice2.all.data$Trialnumber)
choice2.all.data$c.TrialQuad <- choice2.all.data$c.Trialnumber^2
```

#### Trial level: Create df counting how many times each trial was the last trial (C>A) leading to intransitivity

```{r eval=FALSE}

Trialnumber.df <- as.data.frame(table(choice2.all$ThirdTrial, choice2.all$Intrans, choice2.all$f.id))

#head(Trialnumber.df, 190)

names(Trialnumber.df) <- c("Trialnumber", "Intrans", "f.id", "TimesThirdInIntrans")
```

**Exclude those where there is no intransitivity**

```{r eval=FALSE}
Trialnumber.df <- Trialnumber.df[Trialnumber.df$Intrans == 1,]
```

**Organize classes of columns**

```{r eval=FALSE}

Trialnumber.df$Trialnumber <- as.numeric(as.character(Trialnumber.df$Trialnumber))
Trialnumber.df$Intrans <- as.numeric(as.character(Trialnumber.df$Intrans))
```

**Merge w pair level data**

```{r eval=FALSE}

choice2.all.data <- merge(choice2.all.data, Trialnumber.df[,c("Trialnumber", "f.id", "TimesThirdInIntrans")], by = c("Trialnumber", "f.id"), choice2.all.x=T)

choice2.all.data <- choice2.all.data[order(choice2.all.data$f.id, choice2.all.data$Trialnumber),]
```

**Replace NA's in IntransFreq w 0's (these trials have never been the largest trial in a triplet)**

```{r eval=FALSE}
choice2.all.data$IntransFreq <- ifelse(is.na(choice2.all.data$TimesThirdInIntrans), 0, choice2.all.data$TimesThirdInIntrans)
```

#### Trial level: variables that are triple counted in trial level df choice2.all.data - rename them to avoid confusion later

**Note also these are not triple counted in Intransitive df because that is summarized directly from triplet level**

```{r eval=FALSE}
names(choice2.all.data)[which(names(choice2.all.data) == "Intrans")] <- "IntransTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "MisPress")] <- "MisPressTripletsTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "Error")] <- "ErrorTripletsTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "MisPressIntrans")] <- "MisPressIntransTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "ErrorIntrans")] <- "ErrorIntransTripleCounted"
```

Group differences in intransitivies
--------------------------------------------------------

### Old approach: Looking at them separately (control vs test task)

```{r eval=FALSE}
numbers.Intransitive$Group <- as.factor(numbers.Intransitive$Group)

ggplot(data = numbers.Intransitive, aes(x = Group, y = CleanPercentIntr))+
  geom_boxplot()+
  theme_classic()
#Outliers?
ggplot(data = numbers.Intransitive, aes(x = Group, y = CleanPercentIntr))+
  geom_point()+
  ylim(0,20)+
  theme_classic()

aggregate(CleanIntr ~ Group, data=numbers.Intransitive, mean)
aggregate(CleanIntr ~ Group, data=numbers.Intransitive, median)
aggregate(CleanIntr ~ Group, data=numbers.Intransitive, sd)
aggregate(CleanPercentIntr ~ Group, data=numbers.Intransitive, mean)
aggregate(CleanPercentIntr ~ Group, data=numbers.Intransitive, median)
aggregate(CleanPercentIntr ~ Group, data=numbers.Intransitive, sd)

### Choice task

choice2.Intransitive$Group <- as.factor(choice2.Intransitive$Group)

ggplot(data = choice2.Intransitive, aes(x = Group, y = CleanPercentIntr))+
  geom_boxplot()+
  theme_classic()

ggplot(data = choice2.Intransitive, aes(x = Group, y = CleanPercentIntr))+
  geom_point()+
  theme_classic()

summary(aov(CleanPercentIntr ~ Group, data = choice2.Intransitive))

aggregate(CleanIntr ~ Group, data=choice2.Intransitive, mean)
aggregate(CleanIntr ~ Group, data=choice2.Intransitive, median)
aggregate(CleanIntr ~ Group, data=choice2.Intransitive, sd)

aggregate(CleanPercentIntr ~ Group, data=choice2.Intransitive, mean)
aggregate(CleanPercentIntr ~ Group, data=choice2.Intransitive, median)

kruskal.test(CleanIntr ~ Group, data=choice2.Intransitive)

pairwise.wilcox.test(choice2.Intransitive$CleanIntr, choice2.Intransitive$Group, p.adj="bonferroni", exact=F)
```

Though side note: The distribution of effect sizes within tasks is not normal for either task. This is why we can't use ANOVA to test for group differences within tasks (and therefore go for Kruskall-Wallis)

```{r} 
ggplot(numbers.Intransitive, aes(CleanPercentIntr))+
  geom_histogram()+
  theme_classic()
shapiro.test(numbers.Intransitive$CleanPercentIntr)
# shapiro.test(log(numbers.Intransitive$CleanPercentIntr + 1))

ggplot(choice2.Intransitive, aes(CleanPercentIntr))+
  geom_histogram()+
  theme_classic()
shapiro.test(choice2.Intransitive$CleanPercentIntr)
# shapiro.test(log(choice2.Intransitive$CleanPercentIntr+1))

#Note also that a log transform would also take care of the non-normality for the choice task but not the test task. Basically haven't found a way to make sure that they have "equal" variances. But can at least transform (as below) to make them marginally independent of task.
```

### Problem with it: Significantly unequal variances in distribution of intransitivities (effect size)

```{r eval=FALSE, echo=FALSE}
#Is the variance between the groups equal? NO! (so no anova's lm's etc. This is not the big problem though)
# bartlett.test(CleanPercentIntr ~ Group, data = numbers.Intransitive)

#How about a median split (at 0.175) - isn't as useful
# summary(numbers.Intransitive$CleanPercentIntr)
```

As the Bartlett test and the plot shows.

```{r message=FALSE}
#The variances between the two tasks are very different!
var(numbers.Intransitive$CleanPercentIntr)
var(choice2.Intransitive$CleanPercentIntr)

#Significantly so? YES! (the more important/problematic issue is this)
numbers.Intransitive$Task <- "numbers"
choice2.Intransitive$Task <- "choice"
both.Intransitive <- rbind(numbers.Intransitive, choice2.Intransitive)
both.Intransitive$Task <- as.factor(both.Intransitive$Task)
str(both.Intransitive)

#The distribution of the effect size is not independent of the task!
bartlett.test(CleanPercentIntr ~ Task, data = both.Intransitive)
ggplot(both.Intransitive, aes(CleanPercentIntr, fill = Task))+
  geom_histogram()+
  theme_classic()
```

``` {r echo=FALSE, eval=FALSE}
#One failed idea..
#Median split
median(numbers.Intransitive$CleanPercentIntr)
numbers.Intransitive$IntrBinom <- ifelse(numbers.Intransitive$CleanPercentIntr > median(numbers.Intransitive$CleanPercentIntr), 1, ifelse(numbers.Intransitive$CleanPercentIntr < median(numbers.Intransitive$CleanPercentIntr), 0, ifelse(numbers.Intransitive$CleanPercentIntr == median(numbers.Intransitive$CleanPercentIntr), 1, NA)))
table(numbers.Intransitive$IntrBinom)
with(numbers.Intransitive, table(IntrBinom, Group))
#NOW the group variances are not sig diff
bartlett.test(IntrBinom ~ Group, data = numbers.Intransitive)
aggregate(IntrBinom ~ Group, data=numbers.Intransitive, mean)
aggregate(IntrBinom ~ Group, data=numbers.Intransitive, median)
aggregate(IntrBinom ~ Group, data=numbers.Intransitive, sd)
#Still sig group differences.. (Use this to plot?)
kruskal.test(IntrBinom ~ Group, data=numbers.Intransitive)

#Re-do merged df for plotting
choice2.Intransitive$IntrBinom <- ifelse(choice2.Intransitive$CleanPercentIntr > median(choice2.Intransitive$CleanPercentIntr), 1, ifelse(choice2.Intransitive$CleanPercentIntr < median(choice2.Intransitive$CleanPercentIntr), 0, ifelse(choice2.Intransitive$CleanPercentIntr == median(choice2.Intransitive$CleanPercentIntr), 1, NA)))
with(choice2.Intransitive, table(IntrBinom, Group))
both.Intransitive <- rbind(numbers.Intransitive, choice2.Intransitive)
both.Intransitive$Task <- as.factor(both.Intransitive$Task)
str(both.Intransitive)
```

So transform your DV. Which is best? Go with log..

```{r}
bartlett.test(sqrt(CleanPercentIntr) ~ Task, data = both.Intransitive) #marginal

bartlett.test(log(CleanPercentIntr + 1) ~ Task, data = both.Intransitive) #even less marginal

bartlett.test(((-1)/(CleanPercentIntr+0.001)) ~ Task, data = both.Intransitive) #Doesn't work

ggplot(both.Intransitive, aes(log(CleanPercentIntr + 1), fill = Task))+
  geom_histogram()+
  theme_classic()
```

Log transform spreads the variance in the numbers enough to make the difference in variance almost independent of task.

Step back and think what you are interested in. First plot the data:

```{r}
#GOOD PLOT!
plot.Intransitive.df <- ddply(both.Intransitive, .(Task, Group), summarise,
      MeanCleanPercentIntr = mean(CleanPercentIntr, na.rm=T),
      SeCleanPercentIntr = se(CleanPercentIntr),
      eb.low = MeanCleanPercentIntr - SeCleanPercentIntr,
      eb.high = MeanCleanPercentIntr + SeCleanPercentIntr)
plot.Intransitive.df

#With color
limits <- aes(ymax = plot.Intransitive.df$eb.high, ymin=plot.Intransitive.df$eb.low)
ggplot(data = plot.Intransitive.df, aes(x = Group, y=MeanCleanPercentIntr, group = Task, col = Task))+
  geom_point()+
  geom_line()+
  geom_errorbar(limits, width=0.25)+
  theme_classic()

#For poster
ggplot(data = plot.Intransitive.df, aes(x = Group, y=MeanCleanPercentIntr, group = Task))+
  geom_point(aes(shape = Task))+
  geom_line(aes(linetype = Task))+
  geom_errorbar(limits, width=0.25)+
  ylab("Mean Percentage of Intransitivities")+
  xlab("")+
  theme_classic()+
  theme(axis.title.y = element_text(face="bold", size = 20),
           axis.text.x  = element_text(face="bold", size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20))
```

Are these slopes sig? (Make sure to use transformed DVs!)

```{r}
gm1a <- lm(log(CleanPercentIntr+1) ~ Task, both.Intransitive)#; summary(gm1a)
gm1b <- lm(log(CleanPercentIntr+1) ~ Group, both.Intransitive)# ; summary(gm1b)
gm2 <- lm(log(CleanPercentIntr+1) ~ Group+Task, both.Intransitive)# ; summary(gm2)
gm3 <- lm(log(CleanPercentIntr+1) ~ Group*Task, both.Intransitive)# ; summary(gm3)
#Interactive model is always better!
anova(gm1a, gm2, gm3)
anova(gm1b, gm2, gm3)

#So what does it say? Look at the contrasts first!
contrasts(both.Intransitive$Task) 
contrasts(both.Intransitive$Group)
summary(gm3)
#b0 = mean intrans for both tasks for the C group is >0 (not interesting)
#b1 = ETL group doesn't make sig more intrans in CHOICE task! (good) - simple effect
#b2 = MTL group DOES make sig more intrans in CHOICE task! (good) - simple effect
#b3 = C group makes sig less intrans in NUMBERS task! (not surprising, easy task)
#b4 = Is the effect of task in ETL group same as C. Yes.
#b5 = Is the effect of task in MTL group same as C. Marginally no. 

#BUT the above are not orthogonal contrasts and is comparing both groups to Healthy controls only!

#If we change the contrasts and make them orthogonal there would be no overlapping variance (and seems like answer our question of interest perhaps slightly more indirectly but possibly more fully). We would first compare the ETL group to the C group and then the MTL group to BOTH CONTROL GROUPS!

#Change the contrasts, make them orthogonal
both.Intransitive.contrast <- both.Intransitive
contrasts(both.Intransitive.contrast$Group) <- cbind(c(-1,1, 0), c(-1, -1, 2))
contrasts(both.Intransitive.contrast$Task) <- c(-1, 1)

contrasts(both.Intransitive.contrast$Task)
contrasts(both.Intransitive.contrast$Group)

gm3.con <- lm(log(CleanPercentIntr+1) ~ Group*Task, both.Intransitive.contrast) 
summary(gm3.con)
#b0 = Unweighted grand mean (mean of group means) (sum(aggregate(CleanPercentIntr ~ Group, both.Intransitive.contrast, mean)[,2])/3)
#b1 = Total group effect for ETL compared to healthy controls only (quantified)
#b2 = Total group effect for MTL compared to both control groups (quantified)
#b3 = Total task effect
#b4 = Is the effect of task change same for ETL and C groups? (yes.)
#b5 = Is the effect of task change same for MTL vs both control groups? (No!)

#Simple effect of group 
#Create dummy variables for simple effects instead of changing the contrast in the df
both.Intransitive.contrast$number <- ifelse(both.Intransitive.contrast$Task == "numbers",1,0)
both.Intransitive.contrast$choice <- ifelse(both.Intransitive.contrast$Task == "choice",1,0)
#Simple effect of group for choice task: MTL (Group 2) significantly higher!
gm3.con.sc <- lm(log(CleanPercentIntr+1) ~ Group*number, both.Intransitive.contrast); summary(gm3.con.sc) 
#Simple effect of group for number task: ETL (Group 1) significantly (marg?) higher
gm3.con.sn <- lm(log(CleanPercentIntr+1) ~ Group*choice, both.Intransitive.contrast); summary(gm3.con.sn) 
```

```{r}
#Plot S1
ggplot(data=choice.all.data.clean, aes(x = Trialnumber, y = IntransTripleCounted, group = Group))+
  geom_smooth(method = "loess", aes(linetype = Group), colour = "black") +
  theme_classic()+
  ylab("Number of Times involved in Intransitivity") +
  xlab("Trial Number") +
  scale_color_discrete(breaks = c("C", "ETP", "MTL"),labels = c("Control", "ETL", "MTL"))+
  theme(axis.title.y = element_text(face="bold", size = 20),
           axis.title.x  = element_text(face="bold", size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20))
```