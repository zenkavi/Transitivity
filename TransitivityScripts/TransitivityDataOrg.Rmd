---
title: "TransitivityDataOrg"
author: "Zeynep Enkavi"
date: "January 19, 2015"
output: html_document
---

Organization code
--------------------------------------------------------

```{r echo=FALSE, warning=FALSE, message=FALSE}
setwd("~/Dropbox/CDS/Transitivity")

# source("~/Dropbox/CDS/UsefulFunctions.R")
# rm(packages)

options(digits=6)

library(dplyr)
library(plyr)
library(reshape2)

```

### Read numbers task data in:

```{r eval=FALSE, message=FALSE, warning=FALSE}

numbers.Data <- read.csv("./TransitivityData/complete_data_numbers_new.csv", col.names = c("Trialnumber", "Image_left", "Image_right", "RT", "Choice_1right_4left", "SubjectID", "Group"), header=F)

TrialNumber <- read.csv("./TransitivityData/TrialNumbers.csv")

names(numbers.Data)
str(numbers.Data)
```

### Organize Data 

First columnis the trial number (starting with 0! ??? to 189)  
Second column is the left number  
Third column: right number  
Fourth column: reaction time (-1 = miss)  
Fifth: response (-1: miss; 1 right is bigger, 4: left is bigger)   
Sixth: subject ID  
Seventh: patient group 1:MTL, 2: ETL, 3 Control  

*Trial numbers*

Trial numbers start from 0. Fix by adding 1.

```{r eval=FALSE}
numbers.Data$Trialnumber <- numbers.Data$Trialnumber+1
```

#### Code choice

```{r eval = FALSE}
table(numbers.Data$Choice_1right_4left)
```

In addition to correct choice buttons (1 and 4) there are missed trials (-1) and trials where the wrong button was pressed. Since the wrong button presses were either 3 or 5 they are coded as 4 (left). Missed trials are coded as NA.

```{r eval=FALSE}

numbers.Data$Choice <- ifelse(numbers.Data$Choice_1right_4left == 1, "right",
                              ifelse(numbers.Data$Choice_1right_4left == 4, "left",
                                     ifelse(numbers.Data$Choice_1right_4left == 3, "left", ifelse(numbers.Data$Choice_1right_4left == 5, "left", NA))))

table(numbers.Data$Choice, useNA  = "ifany")

numbers.Data$Choice.image <- ifelse(numbers.Data$Choice == "right", numbers.Data$Image_right, ifelse(numbers.Data$Choice == "left", numbers.Data$Image_left, NA))

table(numbers.Data$Choice.image, useNA  = "ifany")
# if all were transitive 1 -> 0, 2 -> 91, 3, -> 182 etc..

numbers.Data$Choice.left1.right0 <- ifelse(numbers.Data$Choice == "left", 1, ifelse(numbers.Data$Choice == "right", 0, NA))

table(numbers.Data$Choice.left1.right0, useNA  = "ifany")
```

#### Assign groups

```{r eval=FALSE}
table(numbers.Data$Group)/190

numbers.Data$Group <- ifelse(numbers.Data$Group == 1, "MTL", 
                ifelse(numbers.Data$Group == 2, "ETL","C"))
```

#### Factorize id's

```{r eval=FALSE}
head(numbers.Data$SubjectID)

numbers.Data$f.id <- as.factor(numbers.Data$SubjectID)

head(numbers.Data$f.id)
```

#### Create unique identifier for each pair (Paste variable)

```{r eval=FALSE}
#This is old/ugly code but works fine so won't improve it for now
TrialNumber$Image_right <- ifelse(TrialNumber$Image_right <10, paste(0,as.character(TrialNumber$Image_right,sep="")), TrialNumber$Image_right)
TrialNumber$Image_left <- ifelse(TrialNumber$Image_left <10, paste(0,as.character(TrialNumber$Image_left,sep="")), TrialNumber$Image_left)
TrialNumber$Paste <- paste(TrialNumber$Image_right, TrialNumber$Image_left, sep="")
TrialNumber$Paste<- gsub(" ", "", TrialNumber$Paste)

numbers.Data$Image_right <- ifelse(numbers.Data$Image_right <10, paste(0,as.character(numbers.Data$Image_right,sep="")), numbers.Data$Image_right)
numbers.Data$Image_left <- ifelse(numbers.Data$Image_left <10, paste(0,as.character(numbers.Data$Image_left,sep="")), numbers.Data$Image_left)
numbers.Data$Paste <- paste(numbers.Data$Image_right, numbers.Data$Image_left, sep="")
numbers.Data$Paste<- gsub(" ", "", numbers.Data$Paste)

numbers.Data2 <-  read.csv("./TransitivityData/complete_data_numbers_new.csv", col.names = c("Trialnumber", "Image_left", "Image_right", "RT", "Choice_1right_4left", "SubjectID", "Group"), header=F)
numbers.Data$Image_right <- numbers.Data2$Image_right
numbers.Data$Image_left <- numbers.Data2$Image_left
rm(numbers.Data2)

numbers.Data$Trial<- rep(NA, nrow(numbers.Data))
for (i in 1:nrow(numbers.Data)){
  numbers.Data$Trial[i]<- TrialNumber$Trial[which(numbers.Data$Paste[i] == TrialNumber$Paste)] 
}
rm(i)

head(TrialNumber)
head(numbers.Data)
```

#### Create Error df with counts of number of trials subjects mispressed or timed out

This will be merged with the Intransitive df with individual intransitivity counts later. 

Note: Mispress doesn't include timeout trials.

```{r eval = FALSE}
#Creates df with subject id in col 1 and number of timed out trials in col 2
numbers.TimeOut <- as.data.frame(table(numbers.Data[which(numbers.Data$RT<0), "SubjectID"]))

#Creates df with subject id in col 1 and number of mispressed trials in col 2
numbers.MisPress <- as.data.frame(table(numbers.Data[which(numbers.Data$Choice_1right_4left != 1 & numbers.Data$Choice_1right_4left != 4 & numbers.Data$Choice_1right_4left != (-1)), "SubjectID"]))

#Creates df with subject id in col 1 and number of both kinds of errors in col 2
numbers.EitherError <- as.data.frame(table(numbers.Data[which(numbers.Data$RT <0 | (numbers.Data$Choice_1right_4left != 1 & numbers.Data$Choice_1right_4left != 4 & numbers.Data$Choice_1right_4left != (-1))), "SubjectID"]))

#Merge above three dfs to get numbers of all errors
numbers.Error <- merge(numbers.MisPress, numbers.TimeOut, by="Var1", all = T)
numbers.Error <- merge(numbers.Error, numbers.EitherError, by="Var1", all = T)
names(numbers.Error) <- c("f.id", "MisPress", "TimeOut", "EitherError")
rm(numbers.TimeOut, numbers.MisPress, numbers.EitherError)
#TO BE MERGED TO INTRANSITIVE DF LATER

```

### Count intransitive choices

#### Create temp df where intransitive choices will be counted by creating the 1140 triplets possible out of 20 options (C(20,3) = 1140)

```{r eval=FALSE}
comb <- t(combn(unique(numbers.Data$Image_left),3))
comb <- as.data.frame(comb)
names(comb) <- c("A", "B", "C")
comb$ApreftoB <- rep(NA, nrow(comb))
comb$BpreftoC <- rep(NA, nrow(comb))
comb$CpreftoA <- rep(NA, nrow(comb))
comb$Intrans <- rep(NA, nrow(comb))
comb$TimeOutApreftoB <- rep(NA, nrow(comb))
comb$TimeOutBpreftoC <- rep(NA, nrow(comb))
comb$TimeOutCpreftoA <- rep(NA, nrow(comb))
comb$TimeOut <- rep(NA, nrow(comb))
comb$TimeOutIntrans <- rep(NA, nrow(comb))
comb$MisPressApreftoB <- rep(NA, nrow(comb))
comb$MisPressBpreftoC <- rep(NA, nrow(comb))
comb$MisPressCpreftoA <- rep(NA, nrow(comb))
comb$MisPress <- rep(NA, nrow(comb))
comb$MisPressIntrans <- rep(NA, nrow(comb))
comb$Error <- rep(NA, nrow(comb))
comb$ErrorIntrans <- rep(NA, nrow(comb))
comb$TrialA <- rep(NA, nrow(comb))
comb$TrialB <- rep(NA, nrow(comb))
comb$TrialC <- rep(NA, nrow(comb))
comb$ThirdTrial <- rep(NA, nrow(comb))
comb$PasteA <- rep(NA, nrow(comb))
comb$PasteB <- rep(NA, nrow(comb))
comb$PasteC <- rep(NA, nrow(comb))
```

#### Group data by subjects 

To later apply the function to count intransitivites to each subject.

```{r eval=FALSE}
data_ind <- group_by(numbers.Data, f.id)
```

#### Function 1: Check intransitivity on one row of comb (in one triplet)

Output: Record choice, intransitivity, TimeOut, MisPress, EitherError, TimeOut+intransitivity, MissPress+intransitivity, EitherError+intransitivity, trial number for each pair, last trial of triplet, pair identifier in one row

```{r eval=FALSE}
comb.row.fn <- function (df, comb.row) {
  # INPUT 
  #   df: individual participants data
  #   comb.row: comb data frame split by row
  j <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$B | df$Image_right == comb.row$B))
  #Record choice for A vs B
  ApreftoB <- ifelse(df$Choice.image[j] == comb.row$A, 1, 0)
  #Record if the trial was TimeOut (i.e. timed out)
  TimeOutApreftoB <- ifelse(df$RT[j] < 0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressApreftoB <- ifelse(df$Choice_1right_4left[j] != 1 & df$Choice_1right_4left[j] != 4 & df$Choice_1right_4left[j] != (-1) , 1, 0)
  #Find trial row in df that has the B vs C choice in comb
  k <- which((df$Image_left == comb.row$B | df$Image_right == comb.row$B) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for B vs C
  BpreftoC <- ifelse(df$Choice.image[k] == comb.row$B, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutBpreftoC <- ifelse(df$RT[k] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressBpreftoC <- ifelse(df$Choice_1right_4left[k] != 1 & df$Choice_1right_4left[k] != 4 & df$Choice_1right_4left[k] != (-1), 1, 0)
  #Find trial row in df that has the A vs C choice in comb
  l <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for A vs C
  CpreftoA <- ifelse(df$Choice.image[l] == comb.row$C, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutCpreftoA <- ifelse(df$RT[l] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressCpreftoA <- ifelse(df$Choice_1right_4left[l] != 1 & df$Choice_1right_4left[l] != 4 & df$Choice_1right_4left[l] != (-1) , 1, 0)
  #A triplet is intransitive if either A>B, B>C and C>A OR A<B, B<C and C<A (the second is the reverse) #Changed on 9/18/14 to assign NA whenever there is NA in choice (which would be the case if timeout is coded so)
  Intrans <- ifelse (ApreftoB == 1 & BpreftoC == 1 & CpreftoA == 1, 1, 
                     ifelse(ApreftoB == 0 & BpreftoC == 0 & CpreftoA == 0, 1, 
                            ifelse(is.na(ApreftoB) == T | is.na(BpreftoC) == T | is.na(CpreftoA) == T, NA,0)))
  #A triplet involves a TimeOut if any of the three trials involved has timed out
  TimeOut <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1, 1, 0)
  #A triplet involves a MisPress if any of the three trials were mispressed
  MisPress <- ifelse(MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
    #A triplet involves an Error if any of the three trials were timed out or mispressed
  Error <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1| MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
  #Mark triplets where there is both an TimeOut and an intransitivity
  #TimeOutIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an MisPress and an intransitivity
  MisPressIntrans <- ifelse((MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an TimeOut or Mispress and an intransitivity
  ErrorIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1 | MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
  TrialA <- df$Trialnumber[j]
  TrialB <- df$Trialnumber[k]
  TrialC <- df$Trialnumber[l]
  ThirdTrial <- max(TrialA, TrialB, TrialC)
  PasteA <- numbers.Data$Paste[j]
  PasteB <- numbers.Data$Paste[k]
  PasteC <- numbers.Data$Paste[l]
  # setup data to return
  ret.dat <- data.frame(A = comb.row$A, 
                        B = comb.row$B,
                        C = comb.row$C,
                        ApreftoB = ApreftoB,
                        BpreftoC = BpreftoC,
                        CpreftoA = CpreftoA,
                        Intrans = Intrans,
                        TimeOutApreftoB = TimeOutApreftoB,
                        TimeOutBpreftoC = TimeOutBpreftoC,
                        TimeOutCpreftoA = TimeOutCpreftoA,
                        TimeOut = TimeOut,
                        #TimeOutIntrans = TimeOutIntrans,
                        MisPressApreftoB = MisPressApreftoB,
                        MisPressBpreftoC = MisPressBpreftoC,
                        MisPressCpreftoA = MisPressCpreftoA,
                        MisPress = MisPress,
                        MisPressIntrans = MisPressIntrans,
                        Error = Error,
                        ErrorIntrans = ErrorIntrans,
                        TrialA = TrialA,
                        TrialB = TrialB,
                        TrialC = TrialC,
                        ThirdTrial = ThirdTrial,
                        PasteA = PasteA,
                        PasteB = PasteB,
                        PasteC = PasteC)
  return(ret.dat)
}
```

Note: Considered coding Mispresses like timeouts where they don't factor in to the intransitivity calculation at all but unlike timeouts where we have no guess on preference we do make a guess for the mispress trials so it made more sense to me to keep track of them instead.

#### Create continuous triplet variable 

To act as levels when applying the row level function to the subject level df

```{r eval=FALSE}
comb <- mutate(comb, 
               id = 1:nrow(comb))
```

#### Function 2: Apply function 1 (row level intransitivity calculation) to subset of data including all triplets for one participant

```{r eval=FALSE}
comb.fn <- function(Data.cut, comb) {
  ddply(comb, .(id), comb.row.fn, df = Data.cut)
}
```

#### Count intransitivities for all subjects [takes time ~ 6 min]

Combine intransitivity calculation for all participant by applying to subject level calculation to all participants  
Output: 1140*number of subject rows recording with output of comb.row.fn function

```{r eval=FALSE}
numbers.all <- ddply(numbers.Data, .(f.id, Group), comb.fn, comb = comb, .progress="text")
```

#### Subject level: Summarize triplet level intransitivity on subject level 

Output: nrow = number of subjects  
Note TimeOut, MisPress and Error are large (not matching the Error df) because they are the number of triplets (not trials!) that involve one OR MORE of these errors (so not triple counting)

```{r eval=FALSE}
numbers.Intransitive <- ddply(numbers.all, .(f.id, Group), summarise, 
             Intrans = sum(Intrans, na.rm=T),
             TimeOutTriplets = sum(TimeOut, na.rm=T),
             MisPressTriplets = sum(MisPress),
             ErrorTriplets = sum(Error, na.rm=T),
             #TimeOutIntransTriplets = sum(TimeOutIntrans),
             MisPressIntransTriplets = sum(MisPressIntrans, na.rm=T),
             ErrorIntransTriplets = sum(ErrorIntrans, na.rm=T))
```

#### Subject level: Assign number of missed trials from the Error df to the correct subject in Intrans df

```{r eval=FALSE}
# Create additional subject level variables and calculations of percentages
numbers.Intransitive$TimeOutTrials <- rep(NA, nrow(numbers.Intransitive))
numbers.Intransitive$MisPressTrials <- rep(NA, nrow(numbers.Intransitive))
numbers.Intransitive$EitherErrorTrials <- rep(NA, nrow(numbers.Intransitive))

#Assign number of missed trials from the Error df to the correct subject in Intrans df
for (i in 1:nrow(numbers.Error)){
  j <- which(as.character(numbers.Intransitive$f.id) == as.character(numbers.Error$f.id[i]))
  numbers.Intransitive$TimeOutTrials[j] <- numbers.Error$TimeOut[i]
  numbers.Intransitive$MisPressTrials[j] <- numbers.Error$MisPress[i]
  numbers.Intransitive$EitherErrorTrials[j] <- numbers.Error$EitherError[i]
}

rm(i, j)

#Or give 0 if there are no missed trials
numbers.Intransitive$TimeOutTrials <- ifelse(is.na(numbers.Intransitive$TimeOutTrials) == T, 0, numbers.Intransitive$TimeOutTrials)
numbers.Intransitive$MisPressTrials <- ifelse(is.na(numbers.Intransitive$MisPressTrials) == T, 0, numbers.Intransitive$MisPressTrials)
numbers.Intransitive$EitherErrorTrials <- ifelse(is.na(numbers.Intransitive$EitherErrorTrials) == T, 0, numbers.Intransitive$EitherErrorTrials)
```

#### Subject level: Calculate percentages of intransitivities and timed out/mispressed trials


```{r eval=FALSE}
#Trial level calculations
numbers.Intransitive$PercentTimeOutTrials <- numbers.Intransitive$TimeOutTrials/190*100
numbers.Intransitive$PercentMisPressTrials <- numbers.Intransitive$MisPressTrials/190*100
numbers.Intransitive$PercentEitherErrorTrials <- numbers.Intransitive$EitherErrorTrials/190*100

#Triplet level calculations
#numbers.Intransitive$PercentIntr <- numbers.Intransitive$Intrans/1140*100 # Removed var because was creating confusion w the percent of clean intransitives which is the only one that should be used
numbers.Intransitive$PercentTimeOutTriplets <- numbers.Intransitive$TimeOutTriplets/1140*100 #Note that coding the choice for timeout trials as NA doesn't mean there aren't triplets that are affected by this
numbers.Intransitive$PercentMisPressTriplets <- numbers.Intransitive$MisPressTriplets/1140*100
numbers.Intransitive$PercentEitherErrorTriplets <- numbers.Intransitive$ErrorTriplets/1140*100

#Percent of intransitivies that include an error (now only mispress errors because timeouts are not counted in Intrans)
numbers.Intransitive$PIntrError<- numbers.Intransitive$ErrorIntransTriplets/ numbers.Intransitive$Intrans *100
numbers.Intransitive$PIntrError <- ifelse(is.na(numbers.Intransitive$PIntrError), 0, numbers.Intransitive$PIntrError) #People who don't have intransitivities get NaN for this otherwise. Here I replaced them with 0's since I only care about those who have affected intransitivities

numbers.Intransitive$CleanTriplets <- 1140 - numbers.Intransitive$ErrorTriplets
numbers.Intransitive$CleanIntr <- numbers.Intransitive$Intrans - numbers.Intransitive$ErrorIntransTriplets
numbers.Intransitive$CleanPercentIntr <- numbers.Intransitive$CleanIntr/numbers.Intransitive$CleanTriplets *100
```

#### Trial level: Create pair level intransitivity count

**Temp df before aggregating. Has numbers.all three "Paste"s (ie trials in one column)**

```{r eval=FALSE}
numbers.all.m <- melt(numbers.all[, c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans","TrialA", "TrialB", "TrialC")], id = c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans"))
```

**Aggregate df to sum (I think Err and ErrIntrans are less usefull here. Using only Intrans so far.) Note: Total intransitivities will be triple counted this way (because numbers.all three pairs that are involved in an intransitivity take the dummy variable 1)**

```{r eval=FALSE}
sum.na <- function(x){sum(x, na.rm=T)}

numbers.all.ag.test <- aggregate(numbers.all.m[,c("Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans")], by = list(f.id = numbers.all.m$f.id, Group = numbers.all.m$Group, Trialnumber = numbers.all.m$value), FUN = "sum.na")
```

**Merge Intransitivity info with rest of trial level data**

```{r eval=FALSE}
numbers.all.data <- merge(numbers.Data, numbers.all.ag, by = c("f.id", "Group", "Trialnumber"), all.x = T)

rm(numbers.all.ag, numbers.all.m)
```

#### Trial level: Create centered trial number and quadratic trial term

```{r eval=FALSE}
numbers.all.data$c.Trialnumber <- numbers.all.data$Trialnumber - mean(numbers.all.data$Trialnumber)
numbers.all.data$c.TrialQuad <- numbers.all.data$c.Trialnumber^2
```

#### Trial level: Create df counting how many times each trial was the last trial (C>A) leading to intransitivity

```{r eval=FALSE}

Trialnumber.df <- as.data.frame(table(numbers.all$ThirdTrial, numbers.all$Intrans, numbers.all$f.id))

#head(Trialnumber.df, 190)

names(Trialnumber.df) <- c("Trialnumber", "Intrans", "f.id", "TimesThirdInIntrans")
```

**Exclude those where there is no intransitivity**

```{r eval=FALSE}
Trialnumber.df <- Trialnumber.df[Trialnumber.df$Intrans == 1,]
```

**Organize classes of columns**

```{r eval=FALSE}

Trialnumber.df$Trialnumber <- as.numeric(as.character(Trialnumber.df$Trialnumber))
Trialnumber.df$Intrans <- as.numeric(as.character(Trialnumber.df$Intrans))
```

**Merge w pair level data**

```{r eval=FALSE}

numbers.all.data <- merge(numbers.all.data, Trialnumber.df[,c("Trialnumber", "f.id", "TimesThirdInIntrans")], by = c("Trialnumber", "f.id"), all.x=T)

numbers.all.data <- numbers.all.data[order(numbers.all.data$f.id, numbers.all.data$Trialnumber),]
```

**Replace NA's in IntransFreq w 0's (these trials have never been the largest trial in a triplet)**

```{r eval=FALSE}
numbers.all.data$IntransFreq <- ifelse(is.na(numbers.all.data$TimesThirdInIntrans), 0, numbers.all.data$TimesThirdInIntrans)
```

#### Trial level: variables that are triple counted in trial level df numbers.all.data - rename them to avoid confusion later

**Note also these are not triple counted in Intransitive df because that is summarized directly from triplet level**

```{r eval=FALSE}
names(numbers.all.data)[which(names(numbers.all.data) == "Intrans")] <- "IntransTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "MisPress")] <- "MisPressTripletsTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "Error")] <- "ErrorTripletsTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "MisPressIntrans")] <- "MisPressIntransTripleCounted"
names(numbers.all.data)[which(names(numbers.all.data) == "ErrorIntrans")] <- "ErrorIntransTripleCounted"
```

REPEAT SAME CLEANING OF TIMEOUTS FOR CHOICE DATA
-----------------------------------------------------------------

### Read choice2 task data in:

```{r eval=FALSE, message=FALSE, warning=FALSE}
######### Read Data in
choice2.Data <- read.csv("./TransitivityData/complete_data.csv")

names(choice2.Data)
```

### Organize Data 

#### Code choice

In addition to correct choice buttons (1 and 4) there are missed trials (-1) and trials where the wrong button was pressed. Since the wrong button presses were either 3 or 5 they are coded as 4 (left).

```{r eval=FALSE}
table(choice2.Data$Choice_1left_4right)

#Make sure TimeOut trials are coded correctly (as -1) for choice (this only seems to be a problem for one single trial (4) for one subject (3574), probably a csv error?) 

choice2.Data$Choice_1left_4right <- ifelse(choice2.Data$RT<0, (-1), choice2.Data$Choice_1left_4right) 

#Notice change of one trial from 1 to -1 in table
table(choice2.Data$Choice_1left_4right)

choice2.Data$Choice <- ifelse(choice2.Data$Choice_1left_4right == 1, "left",
                              ifelse(choice2.Data$Choice_1left_4right == 4, "right",
                                     ifelse(choice2.Data$Choice_1left_4right == 2, "left", ifelse(choice2.Data$Choice_1left_4right == 3, "right", ifelse(choice2.Data$Choice_1left_4right == 5, "right", NA)))))

table(choice2.Data$Choice, useNA  = "ifany")

choice2.Data$Choice.image <- ifelse(choice2.Data$Choice == "right", choice2.Data$Image_right, ifelse(choice2.Data$Choice == "left", choice2.Data$Image_left, NA))

table(choice2.Data$Choice.image, useNA  = "ifany")
# if all were transitive 1 -> 0, 2 -> 91, 3, -> 182 etc..

choice2.Data$Choice.left1.right0 <- ifelse(choice2.Data$Choice == "left", 1, ifelse(choice2.Data$Choice == "right", 0, NA))

table(choice2.Data$Choice.left1.right0, useNA  = "ifany")
```

#### Assign groups

```{r eval=FALSE}
table(choice2.Data$Group)/190

choice2.Data$Group <- ifelse(choice2.Data$Group == 1, "MTL", 
                ifelse(choice2.Data$Group == 2, "ETL","C"))
```

#### Factorize id's

```{r eval=FALSE}
head(choice2.Data$SubjectID)

choice2.Data$f.id <- as.factor(choice2.Data$SubjectID)

head(choice2.Data$f.id)
```

#### Create unique identifier for each pair (Paste variable)

```{r eval=FALSE}
choice2.Data$Image_right <- ifelse(choice2.Data$Image_right <10, paste(0,as.character(choice2.Data$Image_right,sep="")), choice2.Data$Image_right)
choice2.Data$Image_left <- ifelse(choice2.Data$Image_left <10, paste(0,as.character(choice2.Data$Image_left,sep="")), choice2.Data$Image_left)
choice2.Data$Paste <- paste(choice2.Data$Image_right, choice2.Data$Image_left, sep="")
choice2.Data$Paste<- gsub(" ", "", choice2.Data$Paste)

choice2.Data2 <-  read.csv("./TransitivityData/complete_data.csv")
choice2.Data$Image_right <- choice2.Data2$Image_right
choice2.Data$Image_left <- choice2.Data2$Image_left
rm(choice2.Data2)

choice2.Data$Trial<- rep(NA, nrow(choice2.Data))
for (i in 1:nrow(choice2.Data)){
  choice2.Data$Trial[i]<- TrialNumber$Trial[which(choice2.Data$Paste[i] == TrialNumber$Paste)] 
}

rm(i)

head(TrialNumber)
head(choice2.Data)
```

#### Create Error df with counts of number of trials subjects mispressed or timed out

This will be merged with the Intransitive df with individual intransitivity counts later. 

Note: Mispress doesn't include timeout trials.

```{r eval = FALSE}
#Creates df with subject id in col 1 and number of timed out trials in col 2
choice2.TimeOut <- as.data.frame(table(choice2.Data[which(choice2.Data$RT<0), "SubjectID"]))

#Creates df with subject id in col 1 and number of mispressed trials in col 2
choice2.MisPress <- as.data.frame(table(choice2.Data[which(choice2.Data$Choice_1left_4right != 1 & choice2.Data$Choice_1left_4right != 4 & choice2.Data$Choice_1left_4right != (-1)), "SubjectID"]))

#Creates df with subject id in col 1 and number of both kinds of errors in col 2
choice2.EitherError <- as.data.frame(table(choice2.Data[which(choice2.Data$RT <0 | (choice2.Data$Choice_1left_4right != 1 & choice2.Data$Choice_1left_4right != 4 & choice2.Data$Choice_1left_4right != (-1))), "SubjectID"]))

#Merge above three dfs to get choice2 of all errors
choice2.Error <- merge(choice2.MisPress, choice2.TimeOut, by="Var1", all = T)
choice2.Error <- merge(choice2.Error, choice2.EitherError, by="Var1", all = T)
names(choice2.Error) <- c("f.id", "MisPress", "TimeOut", "EitherError")
rm(choice2.TimeOut, choice2.MisPress, choice2.EitherError)
#TO BE MERGED TO INTRANSITIVE DF LATER

```

### Count intransitive choices

#### Create temp df where intransitive choices will be counted by creating the 1140 triplets possible out of 20 options (C(20,3) = 1140)

```{r eval=FALSE}
comb <- t(combn(unique(choice2.Data$Image_left),3))
comb <- as.data.frame(comb)
names(comb) <- c("A", "B", "C")
comb$ApreftoB <- rep(NA, nrow(comb))
comb$BpreftoC <- rep(NA, nrow(comb))
comb$CpreftoA <- rep(NA, nrow(comb))
comb$Intrans <- rep(NA, nrow(comb))
comb$TimeOutApreftoB <- rep(NA, nrow(comb))
comb$TimeOutBpreftoC <- rep(NA, nrow(comb))
comb$TimeOutCpreftoA <- rep(NA, nrow(comb))
comb$TimeOut <- rep(NA, nrow(comb))
comb$TimeOutIntrans <- rep(NA, nrow(comb))
comb$MisPressApreftoB <- rep(NA, nrow(comb))
comb$MisPressBpreftoC <- rep(NA, nrow(comb))
comb$MisPressCpreftoA <- rep(NA, nrow(comb))
comb$MisPress <- rep(NA, nrow(comb))
comb$MisPressIntrans <- rep(NA, nrow(comb))
comb$Error <- rep(NA, nrow(comb))
comb$ErrorIntrans <- rep(NA, nrow(comb))
comb$TrialA <- rep(NA, nrow(comb))
comb$TrialB <- rep(NA, nrow(comb))
comb$TrialC <- rep(NA, nrow(comb))
comb$ThirdTrial <- rep(NA, nrow(comb))
comb$PasteA <- rep(NA, nrow(comb))
comb$PasteB <- rep(NA, nrow(comb))
comb$PasteC <- rep(NA, nrow(comb))
```

#### Group data by subjects 

To later apply the function to count intransitivites to each subject.

```{r eval=FALSE}
data_ind <- group_by(choice2.Data, f.id)
```

#### Function 1: Check intransitivity on one row of comb (in one triplet)

Output: Record choice, intransitivity, TimeOut, MisPress, EitherError, TimeOut+intransitivity, MissPress+intransitivity, EitherError+intransitivity, trial number for each pair, last trial of triplet, pair identifier in one row

```{r eval=FALSE}
comb.row.fn <- function (df, comb.row) {
  # INPUT 
  #   df: individual participants data
  #   comb.row: comb data frame split by row
  j <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$B | df$Image_right == comb.row$B))
  #Record choice for A vs B
  ApreftoB <- ifelse(df$Choice.image[j] == comb.row$A, 1, 0)
  #Record if the trial was TimeOut (i.e. timed out)
  TimeOutApreftoB <- ifelse(df$RT[j] < 0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressApreftoB <- ifelse(df$Choice_1left_4right[j] != 1 & df$Choice_1left_4right[j] != 4 & df$Choice_1left_4right[j] != (-1) , 1, 0)
  #Find trial row in df that has the B vs C choice in comb
  k <- which((df$Image_left == comb.row$B | df$Image_right == comb.row$B) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for B vs C
  BpreftoC <- ifelse(df$Choice.image[k] == comb.row$B, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutBpreftoC <- ifelse(df$RT[k] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressBpreftoC <- ifelse(df$Choice_1left_4right[k] != 1 & df$Choice_1left_4right[k] != 4 & df$Choice_1left_4right[k] != (-1), 1, 0)
  #Find trial row in df that has the A vs C choice in comb
  l <- which((df$Image_left == comb.row$A | df$Image_right == comb.row$A) &
               (df$Image_left == comb.row$C | df$Image_right == comb.row$C))
  #Record choice for A vs C
  CpreftoA <- ifelse(df$Choice.image[l] == comb.row$C, 1, 0)
  #Record if the trial was TimeOutor (i.e. timed out)
  TimeOutCpreftoA <- ifelse(df$RT[l] <0 , 1, 0)
  #Record if the trial was MisPressed
  MisPressCpreftoA <- ifelse(df$Choice_1left_4right[l] != 1 & df$Choice_1left_4right[l] != 4 & df$Choice_1left_4right[l] != (-1) , 1, 0)
  #A triplet is intransitive if either A>B, B>C and C>A OR A<B, B<C and C<A (the second is the reverse) #Changed on 9/18/14 to assign NA whenever there is NA in choice (which would be the case if timeout is coded so)
  Intrans <- ifelse (ApreftoB == 1 & BpreftoC == 1 & CpreftoA == 1, 1, 
                     ifelse(ApreftoB == 0 & BpreftoC == 0 & CpreftoA == 0, 1, 
                            ifelse(is.na(ApreftoB) == T | is.na(BpreftoC) == T | is.na(CpreftoA) == T, NA,0)))
  #A triplet involves a TimeOut if any of the three trials involved has timed out
  TimeOut <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1, 1, 0)
  #A triplet involves a MisPress if any of the three trials were mispressed
  MisPress <- ifelse(MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
    #A triplet involves an Error if any of the three trials were timed out or mispressed
  Error <- ifelse(TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1| MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1, 1, 0)
  #Mark triplets where there is both an TimeOut and an intransitivity
  #TimeOutIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an MisPress and an intransitivity
  MisPressIntrans <- ifelse((MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
    #Mark triplets where there is both an TimeOut or Mispress and an intransitivity
  ErrorIntrans <- ifelse((TimeOutApreftoB == 1 | TimeOutBpreftoC == 1 | TimeOutCpreftoA == 1 | MisPressApreftoB == 1 | MisPressBpreftoC == 1 | MisPressCpreftoA == 1) & Intrans==1, 1, 0)
  TrialA <- df$Trialnumber[j]
  TrialB <- df$Trialnumber[k]
  TrialC <- df$Trialnumber[l]
  ThirdTrial <- max(TrialA, TrialB, TrialC)
  PasteA <- choice2.Data$Paste[j]
  PasteB <- choice2.Data$Paste[k]
  PasteC <- choice2.Data$Paste[l]
  # setup data to return
  ret.dat <- data.frame(A = comb.row$A, 
                        B = comb.row$B,
                        C = comb.row$C,
                        ApreftoB = ApreftoB,
                        BpreftoC = BpreftoC,
                        CpreftoA = CpreftoA,
                        Intrans = Intrans,
                        TimeOutApreftoB = TimeOutApreftoB,
                        TimeOutBpreftoC = TimeOutBpreftoC,
                        TimeOutCpreftoA = TimeOutCpreftoA,
                        TimeOut = TimeOut,
                        #TimeOutIntrans = TimeOutIntrans,
                        MisPressApreftoB = MisPressApreftoB,
                        MisPressBpreftoC = MisPressBpreftoC,
                        MisPressCpreftoA = MisPressCpreftoA,
                        MisPress = MisPress,
                        MisPressIntrans = MisPressIntrans,
                        Error = Error,
                        ErrorIntrans = ErrorIntrans,
                        TrialA = TrialA,
                        TrialB = TrialB,
                        TrialC = TrialC,
                        ThirdTrial = ThirdTrial,
                        PasteA = PasteA,
                        PasteB = PasteB,
                        PasteC = PasteC)
  return(ret.dat)
}
```

#### Create continuous triplet variable 

To act as levels when applying the row level function to the subject level df

```{r eval=FALSE}
comb <- mutate(comb, 
               id = 1:nrow(comb))
```

#### Function 2: Apply function 1 (row level intransitivity calculation) to subset of data including all triplets for one participant

```{r eval=FALSE}
comb.fn <- function(Data.cut, comb) {
  ddply(comb, .(id), comb.row.fn, df = Data.cut)
}
```

#### Count intransitivities for all subjects [takes time ~ 6 min]

Combine intransitivity calculation for all participant by applying to subject level calculation to all participants  
Output: 1140*number of subject rows recording with output of comb.row.fn function

```{r eval=FALSE}
choice2.all <- ddply(choice2.Data, .(f.id, Group), comb.fn, comb = comb, .progress="text")
```

#### Subject level: Summarize triplet level intransitivity on subject level 

Output: nrow = number of subjects  
Note TimeOut, MisPress and Error are large choice2 (not matching the Error df) because they are the number of triplets (not trials!) that involve one OR MORE of these errors (so not triple counting)

```{r eval=FALSE}
choice2.Intransitive <- ddply(choice2.all, .(f.id, Group), summarise, 
             Intrans = sum(Intrans, na.rm=T),
             TimeOutTriplets = sum(TimeOut, na.rm=T),
             MisPressTriplets = sum(MisPress),
             ErrorTriplets = sum(Error, na.rm=T),
             #TimeOutIntransTriplets = sum(TimeOutIntrans),
             MisPressIntransTriplets = sum(MisPressIntrans, na.rm=T),
             ErrorIntransTriplets = sum(ErrorIntrans, na.rm=T))
```

#### Subject level: Assign number of missed trials from the Error df to the correct subject in Intrans df

```{r eval=FALSE}
# Create additional subject level variables and calculations of percentages
choice2.Intransitive$TimeOutTrials <- rep(NA, nrow(choice2.Intransitive))
choice2.Intransitive$MisPressTrials <- rep(NA, nrow(choice2.Intransitive))
choice2.Intransitive$EitherErrorTrials <- rep(NA, nrow(choice2.Intransitive))

#Assign number of missed trials from the Error df to the correct subject in Intrans df
for (i in 1:nrow(choice2.Error)){
  j <- which(as.character(choice2.Intransitive$f.id) == as.character(choice2.Error$f.id[i]))
  choice2.Intransitive$TimeOutTrials[j] <- choice2.Error$TimeOut[i]
  choice2.Intransitive$MisPressTrials[j] <- choice2.Error$MisPress[i]
  choice2.Intransitive$EitherErrorTrials[j] <- choice2.Error$EitherError[i]
}

rm(i, j)

#Or give 0 if there are no missed trials
choice2.Intransitive$TimeOutTrials <- ifelse(is.na(choice2.Intransitive$TimeOutTrials) == T, 0, choice2.Intransitive$TimeOutTrials)
choice2.Intransitive$MisPressTrials <- ifelse(is.na(choice2.Intransitive$MisPressTrials) == T, 0, choice2.Intransitive$MisPressTrials)
choice2.Intransitive$EitherErrorTrials <- ifelse(is.na(choice2.Intransitive$EitherErrorTrials) == T, 0, choice2.Intransitive$EitherErrorTrials)
```

#### Subject level: Calculate percentages of intransitivities and timed out/mispressed trials

```{r eval=FALSE}
#Trial level calculations
choice2.Intransitive$PercentTimeOutTrials <- choice2.Intransitive$TimeOutTrials/190*100
choice2.Intransitive$PercentMisPressTrials <- choice2.Intransitive$MisPressTrials/190*100
choice2.Intransitive$PercentEitherErrorTrials <- choice2.Intransitive$EitherErrorTrials/190*100

#Triplet level calculations
#choice2.Intransitive$PercentIntr <- choice2.Intransitive$Intrans/1140*100 # Removed var because was creating confusion w the percent of clean intransitives which is the only one that should be used
choice2.Intransitive$PercentTimeOutTriplets <- choice2.Intransitive$TimeOutTriplets/1140*100 #Note that coding the choice for timeout trials as NA doesn't mean there aren't triplets that are affected by this
choice2.Intransitive$PercentMisPressTriplets <- choice2.Intransitive$MisPressTriplets/1140*100
choice2.Intransitive$PercentEitherErrorTriplets <- choice2.Intransitive$ErrorTriplets/1140*100

#Percent of intransitivies that include an error (now only mispress errors because timeouts are not counted in Intrans)
choice2.Intransitive$PIntrError<- choice2.Intransitive$ErrorIntrans/ choice2.Intransitive$Intrans *100
# choice2.Intransitive$PIntrError <- ifelse(is.na(choice2.Intransitive$PIntrError), 0, choice2.Intransitive$PIntrError) #People who don't have intransitivities get NaN for this otherwise. Here I replaced them with 0's since I only care about those who have affected intransitivities BUT commented out because there isn't anyone without intransitivities

choice2.Intransitive$CleanTriplets <- 1140 - choice2.Intransitive$ErrorTriplets
choice2.Intransitive$CleanIntr <- choice2.Intransitive$Intrans - choice2.Intransitive$ErrorIntransTriplets
choice2.Intransitive$CleanPercentIntr <- choice2.Intransitive$CleanIntr/choice2.Intransitive$CleanTriplets *100
```

#### Trial level: Create pair level intransitivity count

**Temp df before aggregating. Has choice2.all three "Paste"s (ie trials in one column)**

```{r eval=FALSE}
choice2.all.m <- melt(choice2.all[, c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans","TrialA", "TrialB", "TrialC")], id = c("f.id", "Group", "Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans"))
```

**Aggregate df to sum (I think Err and ErrIntrans are less usefull here. Using only Intrans so far.) Note: Total intransitivities will be triple counted this way (because choice2.all three pairs that are involved in an intransitivity take the dummy variable 1)**

```{r eval=FALSE}
choice2.all.ag <- aggregate(choice2.all.m[,c("Intrans", "MisPress","MisPressIntrans","Error","ErrorIntrans")], by = list(f.id = choice2.all.m$f.id, Group = choice2.all.m$Group, Trialnumber = choice2.all.m$value), FUN = "sum.na")
```

**Merge Intransitivity info with rest of trial level data**

```{r eval=FALSE}
choice2.all.data <- merge(choice2.Data, choice2.all.ag, by = c("f.id", "Group", "Trialnumber"), all.x = T)

rm(choice2.all.m, choice2.all.ag)
```

#### Trial level: Create centered trial number and quadratic trial term

```{r eval=FALSE}
choice2.all.data$c.Trialnumber <- choice2.all.data$Trialnumber - mean(choice2.all.data$Trialnumber)
choice2.all.data$c.TrialQuad <- choice2.all.data$c.Trialnumber^2
```

#### Trial level: Create df counting how many times each trial was the last trial (C>A) leading to intransitivity

```{r eval=FALSE}
Trialnumber.df <- as.data.frame(table(choice2.all$ThirdTrial, choice2.all$Intrans, choice2.all$f.id))

# head(Trialnumber.df, 190)

names(Trialnumber.df) <- c("Trialnumber", "Intrans", "f.id", "TimesThirdInIntrans")
```

**Exclude those where there is no intransitivity**

```{r eval=FALSE}
Trialnumber.df <- Trialnumber.df[Trialnumber.df$Intrans == 1,]
```

**Organize classes of columns**

```{r eval=FALSE}
Trialnumber.df$Trialnumber <- as.numeric(as.character(Trialnumber.df$Trialnumber))
Trialnumber.df$Intrans <- as.numeric(as.character(Trialnumber.df$Intrans))
```

**Merge w pair level data**

```{r eval=FALSE}

choice2.all.data <- merge(choice2.all.data, Trialnumber.df[,c("Trialnumber", "f.id", "TimesThirdInIntrans")], by = c("Trialnumber", "f.id"), all.x=T)

choice2.all.data <- choice2.all.data[order(choice2.all.data$f.id, choice2.all.data$Trialnumber),]
```

**Replace NA's in IntransFreq w 0's (these trials have never been the largest trial in a triplet)**

```{r eval=FALSE}
choice2.all.data$IntransFreq <- ifelse(is.na(choice2.all.data$TimesThirdInIntrans), 0, choice2.all.data$TimesThirdInIntrans)
```

#### Trial level: variables that are triple counted in trial level df choice2.all.data - rename them to avoid confusion later

**Note also these are not triple counted in Intransitive df because that is summarized directly from triplet level**

```{r eval=FALSE}
names(choice2.all.data)[which(names(choice2.all.data) == "Intrans")] <- "IntransTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "MisPress")] <- "MisPressTripletsTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "Error")] <- "ErrorTripletsTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "MisPressIntrans")] <- "MisPressIntransTripleCounted"
names(choice2.all.data)[which(names(choice2.all.data) == "ErrorIntrans")] <- "ErrorIntransTripleCounted"
```

CLEAN UP and SAVE WORKSPACE
-----------------------------------------------------------

```{r eval=FALSE}
#Clean workspace
rm(choice2.Error, numbers.Error, TrialNumber, Trialnumber.df, comb, comb.fn, comb.row.fn, data_ind, sum.na, choice2.Data, numbers.Data)

#Merge two tasks
numbers.Intransitive$Task <- "numbers"
choice2.Intransitive$Task <- "choice"
both.Intransitive <- rbind(numbers.Intransitive, choice2.Intransitive)
rm(numbers.Intransitive, choice2.Intransitive)

numbers.all$Task <- "numbers"
choice2.all$Task <- "choice"
both.triplet.data <- rbind(numbers.all, choice2.all)
rm(numbers.all, choice2.all)

#Rename trial level data and remove redundant df's
numbers.trial.data <- numbers.all.data
choice2.trial.data <- choice2.all.data
rm(numbers.all.data, choice2.all.data)

#Organize merged df's
str(both.Intransitive)
both.Intransitive$Group <- as.factor(both.Intransitive$Group)
both.Intransitive$Task <- as.factor(both.Intransitive$Task)

str(both.triplet.data)
both.triplet.data$Group <- as.factor(both.triplet.data$Group)
names(both.triplet.data)[which(names(both.triplet.data) == "id")] <- "triplet.id"
str(both.triplet.data)
both.triplet.data$Task <- as.factor(both.triplet.data$Task)

#Save workspace
save.image("~/Dropbox/CDS/Transitivity/TransitivityOutputs/TransitivityDataOrgWorkspace021115.RData")
```